# 3주차 - HTTP, API 설계

## HTTP

**H**yper
**T**ext
**T**rasfer
**P**rotocol 의 약자로 HTML과 같은 하이퍼미디어 문서를 전송하기 위한 애플리케이션 계층 프로토콜이다.

이름에도 있듯이 처음에는 하이퍼 텍스트 문서를 주고 받던 프로토콜이지만 점점 발전하며 이미지와 같은 데이터도 주고 받을 수 있게 되었다.

### HTTP의 역사

HTTP는 1989년  _Tim Berner-LEE_ 를 필두로 CERN 기관의 연구자들이 개발하였다. 단순한 텍스트로 되어 있는 논문의 참고 문헌을 일일이 찾아 읽는 것이 힘들다고 생각하여 이 문제를 해결하고자 만든 것이 HTTP이다. 문서를 링크로 연결할 수 있는 HTML 문서양식을 개발하고 네트워크를 통해 이 HTML을 주고 받을 수 있도록 고안한 프로토콜이 HTTP인 것이다.

* HTTP/0.9
---

1991년에 나온 최초의 HTTP 명세

TCP/IP 위에서 동작하고 GET 요청만 사용할 수 있는 단순한 프로토콜

    GET /page.html

연결이 종료된 이후에 서버는 요청에 관한 어떠한 정보도 저장하지 말 것을 명시하고 있다.

* HTTP/1.0
---

이전 버전에 제한이 너무 많았기 때문에 여러 기능을 추가하여 HTTP/1.0을 만들었다.

추가된 기능으로는

1. HTTP 헤더가 추가되었다. 헤더이름, 콜론, 헤더 값으로 구성되어 있다.

2. HEAD, POST 가 추가되었다. 
    HEAD : 리소스를 다운받지 않고도 메타 데이터를 요청할 수 있도로고 한 메서드

    POST : 클라이언트가 서버에게 데이터를 보낼 수 있게 한 메서드

3. HTTP 요청에 HTTP/1.0 과 같이 HTTP 버전을 명시할 수 있다.

4. HTTP 상태 코드가 추가되었다.
    이전 버전에서는 에러를 HTML에 담아 전달해야 했지만, HTTP/1.0 에서는 상태 코드를 통해 요청 성공.실패 여부를 명시할 수 있게 되었다.
---

    GET /page.html HTTP/1.0

    Header1 : Value1
    Header2 : Value2

    HTTP/1.00 200 OK
    Content-Type : text/html

    <html>
        <p>Hello, world!</p>
    <html>


* HTTP/1.1
---

1997년 1월에 최초로 공개되었다.

추가된 기능

1. HOST 요청 헤더를 반드시 포함하도록 한다.

    HOST 요청 헤더

    HTTP 요청을 보낼 땐 절대경로가 아니라 상대 경로를 명시한다. 하지만 가상 호스팅 때문에 상대 경로뿐만 아니라 어떤 도메인에 접속하는지 명시해줄 필요가 생겼고, HOST 헤더에 도메인을 명시하는 방법으로 구현되었다.


    Get / HTTP/1.1
    HOST : www.google.com

2. 지속 연결 기능이 추가되었다.

    기존에는 요청할 때마다 새로운 TCP 연결을 생성하고, 응답을 마치면 연결을 종료하는 방식으로 동작했지만 전송하는 데이터가 많아질수록 문제가 발생했다.

    따라서 기존에 연결한 TCP 연결을 재사용하는 지속 연결 기능을 지원했다.

3. 파이프라이닝 기능이 추가되었다.

    기본적으로 HTTP 요청은 순차적으로 전송되지만, 이러한 단점을 극복하기 위해 하나의 연결을 통해 앞선 요청의 응답을 기다리지 않고 여러 요청을 순차적으로 보낸 다음 요청 순서대로 응답 받는 파이프라이닝 기술을 도입했다.

4. PUT, OPTIONS, DELETE 등의 메서드가 추가되었다.

5. 캐시를 제어할 수 있는 메커니즘이 추가되었다.

6. HTTP 쿠키가 추가되었다.

등등....

* HTTP/2.0
---
SPDY를 통해 1.1버전의 한계점을 극복하여 HTTP/2를 발표하였다. 

이전 버전과 다른 특징

1. 이진 프로토콜로 읽을 수도 없고 수동으로 만들 수도 없지만 향상된 최적화 기술을 구현할 수 있다.

2. 다중화 프로토콜로 동일한 연결을 통해 병렬 요청을 수행할 수 있다.

3. 헤더를 압축하여 전송된 데이터의 중복과 오버헤드가 제거된다.

4. 서버가 서버 푸시라는 메커니즘으로 클라이언트 캐시에 데이터를 저장할 수 있다.


* HTTP/3.0
---

가장 최신에 만들어진 버전으로 전송 계층에서 TCP 대신 QUIC를 사용한다.

QUIC는 HTTP연결에 대해서 낮은 대기 시간을 제공하도록 설계되었다. 다중화 프로토콜이며 UDP를 통해 여러 스트림을 실행하고 각 스트림에 대해 독립적으로 패킷 손실 감지 및 재전송을 구현하므로, 오류가 발생하면 해당 패킷에 데이터가 있는 스트림만 차단된다.


### HTTP 요청 메서드

HTTP는 요청 메서드를 정의하여, 주어진 리소스에 수행하길 원하는 행동을 나타낸다.

* GET

    특정 리소스의 표시를 요청한다. 오직 데이터를 받기만 한다.

* HEAD

    GET 메서드의 요청과 동일한 응답을 요구하지만, 응답 본문을 포함하지 않는다.

* POST

    특정 리소스에 엔티티를 제출할 때 쓰인다. 서버의 상태의 변화나 부작용을 일으킬 수 있다.

* PUT

    목적 리소스 모든 현재 표시를 요청 payload로 바꾼다.

* DELETE

    특정 리소스를 삭제한다.

* CONNECT

    목적 리소스로 식별되는 서버로의 터널을 맺는다.

* OPTIONS

    목적 리소스의 통신을 설정하는 데 쓰인다.

* TRACE

    목적 리소스의 경로를 따라 메시지 loop-back 테스트를 한다.

* PATCH

    리소스의 부분만을 수정하는 데 쓰인다.


### GET와 POST 메소드의 헤더 분석

Content-Type
---

Content-Type란 HTTP 통신에서 전송되는 데이터의 타입을 나타내는 header정보 중 하나이다. Content-Type 에 따라 데이터를 받는 측에서 데이터를 어떻게 처리해야 할 지 판단한다.

예를 들어 브라우저에서 웹서버로 이미지 데이터를 보낼 경우 Request Header에 Content-Type은 text/plain을 지정해서 보낸다.

반대로 웹서버에서 브라우저로 데이터를 보낼 경우 Response Header에 Content-Type은 image/svg를 지정해서 보낸다.

간단히 말해 **Content-Type으로 요청 또는 응답의 데이터가 어떤 형식인지 판단**할 수 있다.

**GET**방식은 value=text 형식으로 보내지기 때문에 Content-Type가 필요없다.

**POST**방식은 Body에 데이터를 보낼 때 Content-Type이 필요하다.


### HTTP 메서드 사용 예시
![get.png](https://github.com/Juyoung03/2024-1-Web-Study/assets/161465764/c19aace6-c0a5-4fc4-903a-870fa9c699ba)

![post.png](https://github.com/Juyoung03/2024-1-Web-Study/assets/161465764/75690f37-a311-4f7a-b92d-b3073994c0ea)

![put.png](https://github.com/Juyoung03/2024-1-Web-Study/assets/161465764/1c90e278-8ce0-49e2-a043-375d928ff7a3)

![delete.png](https://github.com/Juyoung03/2024-1-Web-Study/assets/161465764/e92d3fd0-d08a-4953-9223-d85f78f54e67)

![options.png](https://github.com/Juyoung03/2024-1-Web-Study/assets/161465764/ce8a6ed4-4123-4a05-ab4f-952eae10f98e)